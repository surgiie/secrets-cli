#!/usr/bin/env bash
if [ "$#" -eq 0 ] || [[ " $@ " =~ " --help " ]]; then

YELLOW='\033[1;33m'
NC='\033[0m'
echo -e "${YELLOW}
█▀ █▀▀ █▀▀ █▀█ █▀▀ ▀█▀ █▀   █▀▀ █   █
▄█ ██▄ █▄▄ █▀▄ ██▄  █  ▄█   █▄▄ █▄▄ █
${NC}"

fi

version_command() {
  echo "$version"
}

secrets_usage() {
  printf "secrets - Manage your secrets as AES-256 encrypted files using your editor and a passphrase.\n\n"

  printf "%s\n" "Usage:"
  printf "  secrets COMMAND\n"
  printf "  secrets [COMMAND] --help | -h\n"
  printf "  secrets --version | -v\n"
  echo

  printf "%s\n" "Commands:"
  printf "  %s   Create new vault item within your editor.\n" "new "
  printf "  %s   Output decrypted vault item.\n" "get "
  printf "  %s   Edit vault yaml item within your editor.\n" "edit"
  printf "  %s   Remove vault item.\n" "rm  "
  printf "  %s   List vault item names.\n" "ls  "
  echo

  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo
    printf "  %s\n" "--version, -v"
    printf "    Show version number\n"
    echo

  fi
}

secrets_new_usage() {
  printf "secrets new - Create new vault item within your editor.\n\n"

  printf "%s\n" "Usage:"
  printf "  secrets new NAME [OPTIONS]\n"
  printf "  secrets new --help | -h\n"
  echo

  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    printf "  %s\n" "--namespace NAMESPACE"
    printf "    The namespace to store vault item in.\n"
    echo

    printf "  %s\n" "--key KEY"
    printf "    The encryption key to use for encryption.\n"
    echo

    printf "  %s\n" "--tmp-ext EXTENSION"
    printf "    When creating a temp file for editing, use this extension for syntax\n    highlighting improvements.\n"
    printf "    %s\n" "Default: yaml"
    echo

    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    printf "%s\n" "Arguments:"

    printf "  %s\n" "NAME"
    printf "    The name of the vault item.\n"
    echo

  fi
}

secrets_get_usage() {
  printf "secrets get - Output decrypted vault item.\n\n"

  printf "%s\n" "Usage:"
  printf "  secrets get NAME [OPTIONS]\n"
  printf "  secrets get --help | -h\n"
  echo

  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    printf "  %s\n" "--namespace NAMESPACE"
    printf "    The namespace to store vault item in.\n"
    echo

    printf "  %s\n" "--key KEY"
    printf "    The encryption key to use for decryption.\n"
    echo

    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    printf "%s\n" "Arguments:"

    printf "  %s\n" "NAME"
    printf "    The name of the vault item.\n"
    echo

  fi
}

secrets_edit_usage() {
  printf "secrets edit - Edit vault yaml item within your editor.\n\n"

  printf "%s\n" "Usage:"
  printf "  secrets edit NAME [OPTIONS]\n"
  printf "  secrets edit --help | -h\n"
  echo

  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    printf "  %s\n" "--namespace NAMESPACE"
    printf "    The namespace to store vault item in.\n"
    echo

    printf "  %s\n" "--key KEY"
    printf "    The encryption key to use for encryption.\n"
    echo

    printf "  %s\n" "--tmp-ext EXTENSION"
    printf "    When creating a temp file for editing, use this extension for syntax\n    highlighting improvements.\n"
    printf "    %s\n" "Default: yaml"
    echo

    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    printf "%s\n" "Arguments:"

    printf "  %s\n" "NAME"
    printf "    The name of the vault item.\n"
    echo

  fi
}

secrets_rm_usage() {
  printf "secrets rm - Remove vault item.\n\n"

  printf "%s\n" "Usage:"
  printf "  secrets rm NAME [OPTIONS]\n"
  printf "  secrets rm --help | -h\n"
  echo

  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    printf "  %s\n" "--namespace NAMESPACE"
    printf "    The namespace to store vault item in.\n"
    echo

    printf "  %s\n" "--force"
    printf "    Remove the secret without confirmation.\n"
    echo

    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    printf "%s\n" "Arguments:"

    printf "  %s\n" "NAME"
    printf "    The name of the vault item.\n"
    echo

  fi
}

secrets_ls_usage() {
  printf "secrets ls - List vault item names.\n\n"

  printf "%s\n" "Usage:"
  printf "  secrets ls [OPTIONS]\n"
  printf "  secrets ls --help | -h\n"
  echo

  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    printf "  %s\n" "--namespace NAMESPACE"
    printf "    The namespace to store vault item in.\n"
    echo

    printf "  %s\n" "--key KEY"
    printf "    The encryption key to use for encryption.\n"
    echo

    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

normalize_input() {
  local arg passthru
  passthru=false

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $passthru == true ]]; then
      input+=("$arg")
    elif [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ "$arg" == "--" ]]; then
      passthru=true
      input+=("$arg")
    else
      input+=("$arg")
    fi

    shift
  done
}

print_in_color() {
  local color="$1"
  shift
  if [[ -z ${NO_COLOR+x} ]]; then
    printf "$color%b\e[0m\n" "$*";
  else
    printf "%b\n" "$*";
  fi
}

red() { print_in_color "\e[31m" "$*"; }
green() { print_in_color "\e[32m" "$*"; }
yellow() { print_in_color "\e[33m" "$*"; }
blue() { print_in_color "\e[34m" "$*"; }
magenta() { print_in_color "\e[35m" "$*"; }
cyan() { print_in_color "\e[36m" "$*"; }
bold() { print_in_color "\e[1m" "$*"; }
underlined() { print_in_color "\e[4m" "$*"; }
red_bold() { print_in_color "\e[1;31m" "$*"; }
green_bold() { print_in_color "\e[1;32m" "$*"; }
yellow_bold() { print_in_color "\e[1;33m" "$*"; }
blue_bold() { print_in_color "\e[1;34m" "$*"; }
magenta_bold() { print_in_color "\e[1;35m" "$*"; }
cyan_bold() { print_in_color "\e[1;36m" "$*"; }
red_underlined() { print_in_color "\e[4;31m" "$*"; }
green_underlined() { print_in_color "\e[4;32m" "$*"; }
yellow_underlined() { print_in_color "\e[4;33m" "$*"; }
blue_underlined() { print_in_color "\e[4;34m" "$*"; }
magenta_underlined() { print_in_color "\e[4;35m" "$*"; }
cyan_underlined() { print_in_color "\e[4;36m" "$*"; }

error(){
    exit_code="${2:-}"
    echo "$(red_bold [ERROR]): $1"
    if [ ! -z "$exit_code" ]; then
        exit $exit_code
    fi
}

warning(){
    exit_code="${2:-}"
    echo "$(yellow_bold [WARNING]): $1"
    if [ ! -z "$exit_code" ]; then
        exit $exit_code
    fi
}
success(){
    echo "$(green_bold [SUCCESS]): $1"
}
info(){
    echo "$(cyan_bold [INFO]): $1"
}

filter_ensure_default_files() {
    context="$(get_cli_context)"
    mkdir -p $(secrets_context_path "items/")
}

remove_trailing() {
    value="$1"
    char="$2"
    echo ${value%"$char"}
}
make_sha() {
    value="$1"
    echo -n "$value" | sha1sum | cut -d ' ' -f1
}
confirm() {
    echo -n "$(yellow_bold [CONFIRM]): $1 [y/n]: "
    read -r -p "" response
    [[ "$response" == [Yy] ]]
}
get_namespace_from_env_vars() {
    context="$(get_cli_context)"
    context=$(echo $context | tr '[:lower:]' '[:upper:]')
    context_var="SECRETS_CLI_${context}_NAMESPACE"
    namespace="${!context_var}"

    if [ -z "$namespace" ]; then
        namespace="${SECRETS_CLI_NAMESPACE:-}"
    fi
    echo $namespace
}

get_passphrase_from_env_vars() {
    context="$(get_cli_context)"
    context=$(echo $context | tr '[:lower:]' '[:upper:]')
    context_var="SECRETS_CLI_${context}_PASSPHRASE"
    passphrase="${!context_var}"

    if [ -z "$passphrase" ]; then
        passphrase="${SECRETS_CLI_PASSPHRASE:-}"
    fi

    echo $passphrase

}

get_cli_context() {
    context="${SECRETS_CLI_CONTEXT:-default}"
    echo $context
}

secrets_context_path() {
    path="${1:-/}"
    context="$(get_cli_context)"
    base="$HOME/.secrets/contexts/$context"
    path="$base/$path"
    echo $(remove_trailing "$path" "/")
}

tmp_path() {
    path="${1:-/}"
    base="/tmp/.secrets"
    path="$base/$path"
    echo $(remove_trailing "$path" "/")
}

secrets_path() {
    path="${1:-/}"
    base="$HOME/.secrets"
    path="$base/$path"
    echo $(remove_trailing "$path" "/")
}

secrets_cli_path() {
    path="${1:-/}"
    base="$SECRETS_CLI_PATH"
    path="$base/$path"
    echo $(remove_trailing "$path" "/")
}

secrets_new_command() {

  if [ -z $EDITOR ]; then
      error "No EDITOR environment variable set. Please set it to your preferred text editor."
      exit 1
  fi

  context="$(get_cli_context)"
  secret_name="${args[name]}"
  secret_sha=$(make_sha "$secret_name")

  namespace=$(get_namespace_from_env_vars)
  if [ ! -z "${args[--namespace]}" ]; then
      namespace="${args[--namespace]}"
  fi

  if [ -z "$namespace" ]; then
      namespace="default"
  fi

  secret_path=$(secrets_context_path "items/$namespace/$secret_sha")

  if [ -f "$secret_path" ]; then
      error "Secret with name '$secret_name' already exists in namespace '$namespace'." 1
  fi

  mkdir -p "$(dirname "$secret_path")"
  passphrase=$(get_passphrase_from_env_vars)

  if [ ! -z "${args[--passphrase]}" ]; then
      passphrase="${args[--passphrase]}"
  fi

  if [ -z "$passphrase" ]; then
      info "Enter passphrase for encryption: "
      read -s passphrase
      info "Confirm passphrase: "
      read -s confirm_passphrase
      if [ "$passphrase" != "$confirm_passphrase" ]; then
          error "Passphrases do not match." 1
      fi
  fi
  rm -rf tmp_path
  mkdir -p "$(tmp_path $context)"
  ext="${args[--tmp-ext]}"
  tmp_file=$(mktemp $(tmp_path "$context/$secret_sha.XXXXXX.$ext"))

  $EDITOR "$tmp_file"

  contents=$(cat "$tmp_file")

  if [ -z "$contents" ]; then
      rm -f $tmp_file
      error "No contents provided." 1
  fi

  contents="$secret_name\n$contents"

  contents=$(echo -e "$contents" | openssl enc -aes-256-cbc -pbkdf2 -salt -pass pass:$passphrase -base64)
  if [ $? -ne 0 ]; then
      error "Encryption failed" 1
  fi

  mkdir -p "$(dirname "$secret_path")"
  echo "$contents" >"$secret_path"

  success "Generated secret '$secret_name' in namespace '$namespace' in context '$context'."
  rm -f $tmp_file

}

secrets_get_command() {

  context="$(get_cli_context)"
  secret_name="${args[name]}"
  secret_sha=$(make_sha "$secret_name")
  namespace=$(get_namespace_from_env_vars)

  if [ ! -z "${args[--namespace]}" ]; then
      namespace="${args[--namespace]}"
  fi

  if [ -z "$namespace" ]; then
      namespace="default"
  fi

  secret_path=$(secrets_context_path "items/$namespace/$secret_sha")

  if [ ! -f "$secret_path" ]; then
      error "Secret with name '$secret_name' doesnt exist in namespace '$namespace'." 1
  fi

  mkdir -p "$(dirname "$secret_path")"
  passphrase=$(get_passphrase_from_env_vars)

  if [ ! -z "${args[--passphrase]}" ]; then
      passphrase="${args[--passphrase]}"
  fi

  if [ -z "$passphrase" ]; then
      info "Enter passphrase for encryption: "
      read -s passphrase
      info "Confirm passphrase: "
      read -s confirm_passphrase
      if [ "$passphrase" != "$confirm_passphrase" ]; then
          error "Passphrases do not match." 1
      fi
  fi

  contents=$(cat "$secret_path" | openssl enc -aes-256-cbc -pbkdf2 -salt -pass pass:$passphrase -d -base64)
  name=$(printf "%s" "$contents" | head -n1)
  contents=$(printf "%s" "$contents" | tail -n +2)

  echo "$contents"

}

secrets_edit_command() {

  context="$(get_cli_context)"
  secret_name="${args[name]}"
  secret_sha=$(make_sha "$secret_name")
  namespace=$(get_namespace_from_env_vars)

  if [ ! -z "${args[--namespace]}" ]; then
      namespace="${args[--namespace]}"
  fi

  if [ -z "$namespace" ]; then
      namespace="default"
  fi

  secret_path=$(secrets_context_path "items/$namespace/$secret_sha")

  if [ ! -f "$secret_path" ]; then
      error "Secret with name '$secret_name' doesnt exist in namespace '$namespace'." 1
  fi

  mkdir -p "$(dirname "$secret_path")"
  passphrase=$(get_passphrase_from_env_vars)

  if [ ! -z "${args[--passphrase]}" ]; then
      passphrase="${args[--passphrase]}"
  fi

  if [ -z "$passphrase" ]; then
      info "Enter passphrase for encryption: "
      read -s passphrase
      info "Confirm passphrase: "
      read -s confirm_passphrase
      if [ "$passphrase" != "$confirm_passphrase" ]; then
          error "Passphrases do not match." 1
      fi
  fi

  contents=$(cat "$secret_path" | openssl enc -aes-256-cbc -pbkdf2 -salt -pass pass:$passphrase -d -base64)
  name=$(printf "%s" "$contents" | head -n1)
  contents=$(printf "%s" "$contents" | tail -n +2)

  rm -rf tmp_path
  mkdir -p "$(tmp_path $context)"
  ext="${args[--tmp-ext]}"
  tmp_file=$(mktemp $(tmp_path "$context/$secret_sha.XXXXXX.$ext"))
  echo -e "$contents" >$tmp_file

  $EDITOR "$tmp_file"

  contents=$(cat "$tmp_file")

  if [ -z "$contents" ]; then
      rm -f $tmp_file
      error "No contents provided." 1
  fi

  contents="$secret_name\n$contents"

  contents=$(echo -e "$contents" | openssl enc -aes-256-cbc -pbkdf2 -salt -pass pass:$passphrase -base64)

  if [ $? -ne 0 ]; then
      error "Encryption failed" 1
  fi

  mkdir -p "$(dirname "$secret_path")"
  echo "$contents" >"$secret_path"

  success "Updated secret '$secret_name' in namespace '$namespace' in context '$context'."
  rm -f $tmp_file

}

secrets_rm_command() {

  context="$(get_cli_context)"
  secret_name="${args[name]}"
  secret_sha=$(make_sha "$secret_name")

  namespace=$(get_namespace_from_env_vars)
  if [ ! -z "${args[--namespace]}" ]; then
      namespace="${args[--namespace]}"
  fi

  if [ -z "$namespace" ]; then
      namespace="default"
  fi

  secret_path=$(secrets_context_path "items/$namespace/$secret_sha")

  if [ ! -f "$secret_path" ]; then
      error "Secret with name '$secret_name' doesnt exist in namespace '$namespace'." 1
  fi

  if [[ ${args[--force]} != 1 ]] && ! confirm "Are you sure you want to remove '$secret_name' from your stored secrets?"; then
      warning "Aborted." 1
  fi

  rm -f "$secret_path"
  success "Removed secret '$secret_name' in namespace '$namespace' in context '$context'."

}

secrets_ls_command() {

  context="$(get_cli_context)"
  secret_name="${args[name]}"
  secret_sha=$(make_sha "$secret_name")

  namespace=""
  if [ ! -z "${args[--namespace]}" ]; then
      namespace="${args[--namespace]}"
  fi

  declare -A secrets
  passphrase=$(get_passphrase_from_env_vars)

  if [ ! -z "${args[--passphrase]}" ]; then
      passphrase="${args[--passphrase]}"
  fi

  if [ -z "$passphrase" ]; then
      info "Enter passphrase for encryption: "
      read -s passphrase
      info "Confirm passphrase: "
      read -s confirm_passphrase
      if [ "$passphrase" != "$confirm_passphrase" ]; then
          error "Passphrases do not match." 1
      fi
  fi
  if [ ! -z "$namespace" ]; then
      secrets_path=$(secrets_context_path "items/$namespace")
  else
      secrets_path=$(secrets_context_path "items")
  fi

  encrypter="$HOME/dotfiles/common/lib/docker/encrypt-cli/docker"

  for file in $(find "$secrets_path" -type f); do
      namespace="$(basename $(dirname $file))"

      contents=$(cat "$file" | openssl enc -aes-256-cbc -pbkdf2 -salt -pass pass:$passphrase -d -base64)

      if [ $? -ne 0 ]; then
          error "Decryption failed: $contents" 1
      fi

      item_name=$(printf "%s" "$contents" | head -n1)

      if [[ -z ${secrets[$namespace]+_} ]]; then
          secrets[$namespace]=""
      fi

      secrets[$namespace]="${secrets[$namespace]} $item_name"
  done

  if [ ${#secrets[@]} -eq 0 ]; then
      warning "No secret items found in context '$(green_bold $context)'." 1
  fi
  info "Vault items in context '$(green_bold $context)':"
  for ns in "${!secrets[@]}"; do
      echo "$(green_bold $ns) namespace items:"
      for item in ${secrets[$ns]}; do
          echo "  - $item"
      done
  done

}

parse_requirements() {

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --version | -v)
        version_command
        exit
        ;;

      --help | -h)
        long_usage=yes
        secrets_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  action=${1:-}

  case $action in
    -*) ;;

    new)
      action="new"
      shift
      secrets_new_parse_requirements "$@"
      shift $#
      ;;

    get)
      action="get"
      shift
      secrets_get_parse_requirements "$@"
      shift $#
      ;;

    edit)
      action="edit"
      shift
      secrets_edit_parse_requirements "$@"
      shift $#
      ;;

    rm)
      action="rm"
      shift
      secrets_rm_parse_requirements "$@"
      shift $#
      ;;

    ls)
      action="ls"
      shift
      secrets_ls_parse_requirements "$@"
      shift $#
      ;;

    "")
      secrets_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

secrets_new_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        secrets_new_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  missing_deps=

  if ! command -v yq >/dev/null 2>&1; then
    printf "missing dependency: yq\n" >&2
    missing_deps=1
  else
    deps['yq']="$(command -v yq | head -n1)"
  fi

  if ! command -v sha1sum >/dev/null 2>&1; then
    printf "missing dependency: sha1sum\n" >&2
    missing_deps=1
  else
    deps['sha1sum']="$(command -v sha1sum | head -n1)"
  fi

  if [[ -n $missing_deps ]]; then
    exit 1
  fi

  action="new"

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      --namespace)

        if [[ -n ${2+x} ]]; then
          args['--namespace']="$2"
          shift
          shift
        else
          printf "%s\n" "--namespace requires an argument: --namespace NAMESPACE" >&2
          exit 1
        fi
        ;;

      --key)

        if [[ -n ${2+x} ]]; then
          args['--key']="$2"
          shift
          shift
        else
          printf "%s\n" "--key requires an argument: --key KEY" >&2
          exit 1
        fi
        ;;

      --tmp-ext)

        if [[ -n ${2+x} ]]; then
          args['--tmp-ext']="$2"
          shift
          shift
        else
          printf "%s\n" "--tmp-ext requires an argument: --tmp-ext EXTENSION" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        if [[ -z ${args['name']+x} ]]; then
          args['name']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  if [[ -z ${args['name']+x} ]]; then
    printf "missing required argument: NAME\nusage: secrets new NAME [OPTIONS]\n" >&2

    exit 1
  fi

  [[ -n ${args['--tmp-ext']:-} ]] || args['--tmp-ext']="yaml"

  filter_error=$(filter_ensure_default_files)
  if [[ -n $filter_error ]]; then
    echo "$filter_error" >&2
    exit 1
  fi

}

secrets_get_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        secrets_get_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  missing_deps=

  if ! command -v yq >/dev/null 2>&1; then
    printf "missing dependency: yq\n" >&2
    missing_deps=1
  else
    deps['yq']="$(command -v yq | head -n1)"
  fi

  if ! command -v sha1sum >/dev/null 2>&1; then
    printf "missing dependency: sha1sum\n" >&2
    missing_deps=1
  else
    deps['sha1sum']="$(command -v sha1sum | head -n1)"
  fi

  if [[ -n $missing_deps ]]; then
    exit 1
  fi

  action="get"

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      --namespace)

        if [[ -n ${2+x} ]]; then
          args['--namespace']="$2"
          shift
          shift
        else
          printf "%s\n" "--namespace requires an argument: --namespace NAMESPACE" >&2
          exit 1
        fi
        ;;

      --key)

        if [[ -n ${2+x} ]]; then
          args['--key']="$2"
          shift
          shift
        else
          printf "%s\n" "--key requires an argument: --key KEY" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        if [[ -z ${args['name']+x} ]]; then
          args['name']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  if [[ -z ${args['name']+x} ]]; then
    printf "missing required argument: NAME\nusage: secrets get NAME [OPTIONS]\n" >&2

    exit 1
  fi

  filter_error=$(filter_ensure_default_files)
  if [[ -n $filter_error ]]; then
    echo "$filter_error" >&2
    exit 1
  fi

}

secrets_edit_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        secrets_edit_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  missing_deps=

  if ! command -v yq >/dev/null 2>&1; then
    printf "missing dependency: yq\n" >&2
    missing_deps=1
  else
    deps['yq']="$(command -v yq | head -n1)"
  fi

  if ! command -v sha1sum >/dev/null 2>&1; then
    printf "missing dependency: sha1sum\n" >&2
    missing_deps=1
  else
    deps['sha1sum']="$(command -v sha1sum | head -n1)"
  fi

  if [[ -n $missing_deps ]]; then
    exit 1
  fi

  action="edit"

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      --namespace)

        if [[ -n ${2+x} ]]; then
          args['--namespace']="$2"
          shift
          shift
        else
          printf "%s\n" "--namespace requires an argument: --namespace NAMESPACE" >&2
          exit 1
        fi
        ;;

      --key)

        if [[ -n ${2+x} ]]; then
          args['--key']="$2"
          shift
          shift
        else
          printf "%s\n" "--key requires an argument: --key KEY" >&2
          exit 1
        fi
        ;;

      --tmp-ext)

        if [[ -n ${2+x} ]]; then
          args['--tmp-ext']="$2"
          shift
          shift
        else
          printf "%s\n" "--tmp-ext requires an argument: --tmp-ext EXTENSION" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        if [[ -z ${args['name']+x} ]]; then
          args['name']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  if [[ -z ${args['name']+x} ]]; then
    printf "missing required argument: NAME\nusage: secrets edit NAME [OPTIONS]\n" >&2

    exit 1
  fi

  [[ -n ${args['--tmp-ext']:-} ]] || args['--tmp-ext']="yaml"

  filter_error=$(filter_ensure_default_files)
  if [[ -n $filter_error ]]; then
    echo "$filter_error" >&2
    exit 1
  fi

}

secrets_rm_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        secrets_rm_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  missing_deps=

  if ! command -v yq >/dev/null 2>&1; then
    printf "missing dependency: yq\n" >&2
    missing_deps=1
  else
    deps['yq']="$(command -v yq | head -n1)"
  fi

  if ! command -v sha1sum >/dev/null 2>&1; then
    printf "missing dependency: sha1sum\n" >&2
    missing_deps=1
  else
    deps['sha1sum']="$(command -v sha1sum | head -n1)"
  fi

  if [[ -n $missing_deps ]]; then
    exit 1
  fi

  action="rm"

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      --namespace)

        if [[ -n ${2+x} ]]; then
          args['--namespace']="$2"
          shift
          shift
        else
          printf "%s\n" "--namespace requires an argument: --namespace NAMESPACE" >&2
          exit 1
        fi
        ;;

      --force)

        args['--force']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        if [[ -z ${args['name']+x} ]]; then
          args['name']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  if [[ -z ${args['name']+x} ]]; then
    printf "missing required argument: NAME\nusage: secrets rm NAME [OPTIONS]\n" >&2

    exit 1
  fi

  filter_error=$(filter_ensure_default_files)
  if [[ -n $filter_error ]]; then
    echo "$filter_error" >&2
    exit 1
  fi

}

secrets_ls_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        secrets_ls_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  missing_deps=

  if ! command -v yq >/dev/null 2>&1; then
    printf "missing dependency: yq\n" >&2
    missing_deps=1
  else
    deps['yq']="$(command -v yq | head -n1)"
  fi

  if ! command -v sha1sum >/dev/null 2>&1; then
    printf "missing dependency: sha1sum\n" >&2
    missing_deps=1
  else
    deps['sha1sum']="$(command -v sha1sum | head -n1)"
  fi

  if [[ -n $missing_deps ]]; then
    exit 1
  fi

  action="ls"

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      --namespace)

        if [[ -n ${2+x} ]]; then
          args['--namespace']="$2"
          shift
          shift
        else
          printf "%s\n" "--namespace requires an argument: --namespace NAMESPACE" >&2
          exit 1
        fi
        ;;

      --key)

        if [[ -n ${2+x} ]]; then
          args['--key']="$2"
          shift
          shift
        else
          printf "%s\n" "--key requires an argument: --key KEY" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

  filter_error=$(filter_ensure_default_files)
  if [[ -n $filter_error ]]; then
    echo "$filter_error" >&2
    exit 1
  fi

}

initialize() {
  declare -g version=""
  set -e

  SECRETS_CLI_VERSION="v0.1.0"
  SECRETS_CLI_PATH="$( cd -- "$(dirname "$0")" >/dev/null 2>&1 ; pwd -P )"
  version=$SECRETS_CLI_VERSION

}

run() {

  declare -g long_usage=''
  declare -g -A args=()
  declare -g -A deps=()
  declare -g -a env_var_names=()
  declare -g -a input=()

  normalize_input "$@"
  parse_requirements "${input[@]}"

  case "$action" in
    "new") secrets_new_command ;;
    "get") secrets_get_command ;;
    "edit") secrets_edit_command ;;
    "rm") secrets_rm_command ;;
    "ls") secrets_ls_command ;;
  esac
}

command_line_args=("$@")
initialize
run "${command_line_args[@]}"
